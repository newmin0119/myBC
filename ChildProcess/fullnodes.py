# 파이썬 기본 모듈 import #
import sys, os
from collections import deque
from socket import *
from multiprocessing import Queue
from threading import Thread,Lock,Event

sys.path.append(os.path.dirname(os.path.abspath(os.path.dirname(__file__))))

# 직접 정의한 모듈 및 클래스 import #
from Crypto_tools import *
from Structure.Blocks import *
from Structure.Blockchain import *
from Structure.transactions import validate_transaction

# 채굴 난도를 조절하는 Target_N 변수 #
Target_N = '0000080000000000000000000000000000000000000000000000000000000000'

class FullNode():
    """
    A class of FullNode
    It's ChildProcess, generated by MasterProcess
    It contains 1 semaphore
        - Blockchain
            : Blockchain 모듈의 Blockchain을 멤버 변수로 구성
            : Lock variable을 통해 Semaphore로 구현
            : 이후, Event와 Lock variable로 Mutual Exclusion을 제공하였음
    also It contains 5 threads.
        - Mining Thread
            : memset에 저장된 트랜잭션 중 최대 4개를 읽어와, 머클트리를 구성
            : 머클트리의 루트 값과 더불어 block의 header필드를 모두 구성
            : 이후 nonce값을 조정하여 Header의 hash값이 Target_N 보다 작아지게 함
            : 채굴 성공 시, 자신의 Blockchain에 포함 및, 마스터 프로세스와 peer Fullnode에게 pipe로 전달
            : 채굴 중 peer로부터 Block을 listen했다면, Event객체를 통해 이를 판단
            : 위 판단의 결과로 Block이 유효하다면 일시중단 후 Blockchain에 포함 및 이후 Block으로 채굴 시행
            : 위 판단의 결과로 Block이 유효하지 않다면 기존 Longest Chain을 유지, 이후 진행
        - Snapshot Thread
            : Master Process로 부터 Snapshot 요청을 기다림
            : 요청을 받는 즉시 내부 동작이 실행되는 쓰레드
                -> 내부 동작은 자신이 판단하는 LongestChain을 출력
        - Listen Block Thread
            : peer Fullnodes로부터 Block 수신 대기
            : 수신하는 즉시 Gather Block Thread와 연결된 Inter Thread Queue를 통해 Block을 넘김
        - Gather Block Thread
            : Inter Thread Queue에 object가 삽입되는 것을 대기
            : 삽입된 순간 Event를 set
                -> set되었다면 mining process에서 Semaphore에 해당하는 Blockchain접근을 멈춤
            : 이후 semaphore를 lock하고 멤버 변수인 Blockchain에 Block삽입
            : Blockchain 모듈에 정의된 함수에 따라 자동으로 orphan 혹은 Longest chain에 삽입
            : 마지막에 semaphore를 release
        - Listen Transaction Thread
            : 연결된 Usernodes로부터 pipe를 통해 transaction들을 리스트 형태로 수신
            : 이후 각 트랜잭션 별 검증을 시행하고 이를 user별 transaction과 queue에 삽입
    also It contains 3 functions
        - validate_transaction
            : 오직 Listen Transaction Thread에서 호출
            : 인자로 전달받은 트랜잭션을 이전 트랜잭션과 비교하고
            : 서명을 검증하여
            : 결과를 반환
        - send_block
            : 멤버 변수에 저장된 peer Fullnodes에 전달받은 인자를 송신
            : 여기서 인자는 채굴에 성공한 Block이며, 방법은 pipe를 통해 write
        - run
            : 각 쓰레드를 관리하는 클래스의 메인 함수
            : 각 쓰레드 생성 및 pipe를 알맞게 이어주며 시작
            : 이후 main에서 exit 요청을 모든 fullnode가 공유하고
            : exit 요청을 의미하는 Event가 set된 순간 각 쓰레드를 종료하도록 컨트롤
            : 이후 모든 쓰레드가 종료되었다면 이를 알리고 프로세스를 끝냄
    """
    # 클래스 최초 생성 함수
    def __init__(self,*args) -> None:
        # args
        # genesisBlock,r_pipe,peer_list,w_pipe,fullnode_i
        self.Blockchain             =   BlockChain(args[0],0)
        self.memset                 =   deque()
        self.read_pipe              =   args[1]
        self.peer_pipes             =   args[2]
        self.write_pipe             =   args[3]
        self.node_number            =   args[4]
        self.event_for_Snapshot     =   args[5]
        self.terminate_event        =   args[6]
        self.user_transactions  =   dict()

    
    def run(self):
        # 아래는 Thread와 Lock variable, Event 생성 부분
        self.blockchain_lock            =   Lock()
        self.block_recv_event           =   Event()
        self.mining_thread              =   Thread(target=self.mining_process)
        self.snapshot_thread            =   Thread(target=self.check_snapshot)
        self.listen_block_threads       =   []
        self.block_q                    =   Queue()
        for r_pipe,w_pipe in self.peer_pipes:
            self.listen_block_threads.append(Thread(target=self.listening_block,args=(r_pipe,self.block_q,)))
        dummy_listening_block = Thread(target=self.listening_block,args=(None,self.block_q,))
        self.gather_block_thread        = Thread(target=self.gather_block,args=(self.block_q,))
        self.listen_transaction_thread = Thread(target=self.listen_transaction)
        
        # 아래는 생성한 쓰레드 실행 부분
        self.listen_transaction_thread.start()
        self.mining_thread.start()
        for block_listen_thread in self.listen_block_threads:
            block_listen_thread.start()
        self.gather_block_thread.start()
        self.snapshot_thread.start()
        dummy_listening_block.start()

        # 아래는 생성한 쓰레드 종료를 기다리는 부분
        self.listen_transaction_thread.join()
        self.mining_thread.join()
        for block_listen_thread in self.listen_block_threads:
            block_listen_thread.join()
        dummy_listening_block.join()

        self.gather_block_thread.join()
        
        self.block_q.close()            # block수신이 모두 끝났으니 Queue 닫는 코드
        self.snapshot_thread.join()

        for r_pipe,w_pipe in self.peer_pipes: # 모든 fullnode와의 통신이 끝났으므로 해당 Process 측의 Pipe 한쪽 닫기
            r_pipe.close()
            w_pipe.close()

    def check_snapshot(self):
        while True:
            self.event_for_Snapshot.wait()          # 마스터 프로세스의 스냅샷 요청 대기
            if self.terminate_event.is_set():       # 마스터 프로세스의 종료 요청이 발생했다면 함수 ( 쓰레드 ) 종료
                break
            
            # 출력
            print('\033[34m#########F',self.node_number,'\'s Longest Chain Snapshot##########\033[0m',sep='')
            print(self.Blockchain.__str__())

            self.event_for_Snapshot.clear()         # 스냅샷 재요청 대기를 위한 clear

    # 트랜잭션 인증 함수
    def validate_transaction(self,user_id,i,tx):
        prev_tx = self.user_transactions[user_id][tx['tradeCnt']-1][i]
        return validate_transaction(prev_tx,tx) # transactions module 함수 호출

    #def


    # 채굴 함수
    def mining_process(self):
        """
        Mining process
        """
        while True:
            if self.terminate_event.is_set():
                break
            txs = set()
            for _ in range(min(4,len(self.memset))):
                txs.add(self.memset.popleft())
            self.memset.extendleft(list(txs))         # mining 중간에 해당 프로세스가 중단되는 것을 고려하여, 아직 memset에서 pop 하지 않음
            # 적절히 txs 안에 memset에서 골라오는 함수 필요
            
            header = {
                'blockHeight': self.Blockchain.Longest_Chain[latest][block_info].Header['blockHeight']+1,
                'prevHash': self.Blockchain.Longest_Chain[latest][header_hash],
                'nonce': 0,
                'Merkle_root': ''
            }

            # set_merkle 함수 활용 merkle 생성
            Merkle_tree = Block.set_merkle(txs)
            header['Merkle_root'] = Merkle_tree[1]
            
            # 다른 node에서 mine 성공 여부 event로 checking
            flag_event_occur    = False
            self.block_recv_event.clear()                       # 수행 중 Critical Section 사용 요청이 온다면 끝내기 위해 clear
            
            while sha256(str(header).encode()).hexdigest()>Target_N:    # nonce 값 조정, header's hash<=self.target_N
                
                if self.terminate_event.is_set(): # Master Process의 종료 요청
                    break
                if self.block_recv_event.is_set():  # gather_block thread의 Critical Section 사용 요청
                    flag_event_occur = True         # 사용 요청을 받아 끝났음을 기록
                    break
                header['nonce']+=1
            
            if flag_event_occur:                    # Critical Section 사용요청을 받아 채굴이 중지되었다면
                self.block_recv_event.clear()       # Event clear 후
                continue                            # 채굴 재시작
            
            if self.terminate_event.is_set():       # Master Process의 종료 요청을 받아 채굴이 중지되었다면
                break                               # 채굴 루프 종료
            
            mined_Block = Block(header,Merkle_tree)
            
            self.blockchain_lock.acquire()          # Blockchain은 Critical Section 이므로, 사용 전 lock variable 잠금   
            self.Blockchain.add_block(mined_Block)
            self.blockchain_lock.release()          # Critical Section 사용 후 release
            
            for i in range(len(txs)):
                self.memset.popleft()          # mining 중간에 프로세스 종료되지 않고 잘 전달되었다면, memset에서 사용한 트랜잭션 pop
            
            # 채굴한 block socket으로 peer FullNode로 flooding 하는 함수
            # 먼저 Master Process로 송신
            self.write_pipe.send((self.node_number,mined_Block))
            # 이후 각 peer에게 송신
            self.send_block(mined_Block)

        self.send_block(-1)                         # 채굴이 끝났다면
        self.write_pipe.send((-1,-1))               # pipe 닫기 위한 -1 송신
        self.write_pipe.close()                     # pipe 한쪽 닫기
        

    # 채굴된 블락 받는 함수
    # from another FullNode
    def listening_block(self, pipe, q):
        if pipe is None:
            self.terminate_event.wait()
            q.put(-1)
        else:    
            while True:
                recv_block = pipe.recv()
                q.put(recv_block)
                if recv_block == -1:
                    break

    # 수신한 블락을 블록체인에 포함하고, 이미 포함했다면 미송신
    def gather_block(self,q):
        while len(self.Blockchain.Longest_Chain)<20:
            recv_block = q.get()
            if recv_block == -1:
                break
            if self.terminate_event.is_set():
                continue
            hash = sha256(str(recv_block.Header).encode()).hexdigest()      # 먼저 block header hash

            self.block_recv_event.set()                                     # Critical Section 사용 요청
            self.blockchain_lock.acquire()                                  # Critical Section 사용 전 lock variable 잠금
            is_not_in = self.Blockchain.find_block(hash,recv_block.Header['blockHeight'])   # Block chain 사용
            if not is_not_in:   # is_in
                continue
            
            result=self.Blockchain.add_block(recv_block)                    # Critical Section 사용
            self.blockchain_lock.release()                                  # Critical Section 사용을 마치고 release
            
            if not result:
                continue
            self.send_block(recv_block)
            
    # 채굴한 블락 flooding 함수
    def send_block(self,block):
        # 이후 각 peer에게 송신
        #print('peer로 송신, ',block.Header['blockHeight'])
        for r_pipe,w_pipe in self.peer_pipes:
            w_pipe.send(block)
    
    # 트랜잭션 받는 함수
    # from UserNode
    def listen_transaction(self):
        flag = True
        
        while flag:
            for pipe in self.read_pipe:
                data,user_id = pipe.recv()
                if data==-1:
                    pipe.close()
                    flag = False
                    continue
                
                if user_id not in self.user_transactions.keys():
                    self.user_transactions[user_id] = []
                self.user_transactions[user_id].append([None]*len(data))
                for i in range(len(data)):
                    if self.validate_transaction(user_id,i,data[i]) == 'Verified Successfully':
                        self.user_transactions[user_id][-1][i]=data[i]
                        self.memset.append(str(data[i]))
    def __str__(self):
        myself = '######################################################################\n'
        myself += str(self.node_number) + '\'s longest_chain:'
        myself += self.Blockchain.__str__()
        myself += '######################################################################'
        return myself