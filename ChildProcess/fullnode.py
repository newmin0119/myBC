import sys, os
import threading
from socket import *
from multiprocessing import Process
sys.path.append(os.path.dirname(os.path.abspath(os.path.dirname(__file__))))

from Blockchain.Crypto_tools import *
from Blockchain.Blocks import Block,set_merkle


class FullNode(Process):
    """
    A class of FullNode, generated by MasterProcess

    """
    # 클래스 최초 생성 함수
    def __init__(self,*args) -> None:
        # args
        # genesisBlock,target_N,ip,port,w_pipe,r_pipe
        super().__init__()
        self.longest_chain      =   [args[0]]
        self.memset             =   set()
        self.target_N           =   args[1]
        self.node_Socket        =   socket(AF_INET,SOCK_DGRAM)
        self.ip                 =   args[2]
        self.port               =   args[3]
        self.read_pipe          =   args[4]
        self.peer_fullnode_ip   =   args[5]
        self.write_pipe         =   args[6]
    
    def __str__(self):
        myself = ''
        myself += 'longest_chain:'
        for block in self.longest_chain:
            myself+='\n'+str(block)
        myself+= '\n'

        myself += 'memset:'
        for transaction in self.memset:
            myself+= '\n'+str(transaction)
        myself += '\n'

        myself += 'Socket: '+self.node_Socket.__str__()+'\n'
        myself += 'ip: '+self.ip+'\n'
        myself += 'port: '+str(self.port)+'\n'
        myself += 'Peer\'s address:'
        for peerip in self.peer_fullnode_ip:
            myself += '\n'+peerip
        myself += '\n'

        return myself
    
    def run(self):
        threading.Thread(target=self.listen_transaction()).start()

        

    # 트랜잭션 인증 함수
    def validate_transaction(self, tx) -> bool:
        '''
        ## 1) txs(k)'s buyer == txs(k-1)'s seller
        if txs[i]['input']!=txs[i-1]['output']: return False 
        
        ## 2) Check immutable value
        if txs[i]['Vid']!=txs[i-1]['Vid']: return False
        if txs[i]['modelName']!=txs[i]['modelName']: return False
        if txs[i]['manufacturedTime']!=txs[i]['manufacturedTime']: return False
        '''
        ## 3) Verify signature
        if not verify_sig(tx['sig'],tx['input'],tx['txid']): return False
        
        return True

    #def


    # 채굴 함수
    def mining_process(self):
        """
        Mining process
        """
        while True:
            header = {
                'blockHeight': self.longest_chain[-1].Header['blockHeight']+1,
                'prevHash': sha256(str(self.longest_chain[-1].Header).encode()).hexdigest(),
                'nonce': 0,
                'Merkle_root': ''
            }
            # set_merkle 함수 활용 merkle 생성
            include_transaction = []
            for _ in range(min(len(self.memset),4)):
                include_transaction.append(self.memset.pop())
            Merkle_tree = set_merkle(include_transaction) # -- pool 추후 집합으로 변경 필요
            header['Merkle_root'] = Merkle_tree[0]
            # nonce 값 조정, header's hash<=self.target_N
            while sha256(str(header).encode()).hexdigest()>self.target_N:
                header['nonce']+=1
            header['Merkle_tree'] = Merkle_tree
            self.longest_chain.append(Block(header))
        #while(sha256())
        

    # 채굴된 블락 받는 함수
    # from another FullNode
    def listen_block(self,block):
        if self.validate_transactions(tx):
            self.memset.append(tx)

    # 채굴한 블락 flooding 함수
    # to another FullNode
    def send_block(self,block):
        if self.validate_transactions(tx):
            self.memset.append(tx)
    
    # 트랜잭션 받는 함수
    # from UserNode
    def listen_transaction(self):
        while True:
            for pipe in self.read_pipe:
                data = pipe.recv()
                for x in data:
                    if self.validate_transaction(x):
                        #self.memset.add(x)
                        print(x)