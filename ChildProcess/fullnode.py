import sys, os
from socket import *
from multiprocessing import Process
from threading import Thread
sys.path.append(os.path.dirname(os.path.abspath(os.path.dirname(__file__))))

from Crypto_tools import *
from Structure.Blocks import *
from Structure.Blockchain import *


class FullNode(Process):
    """
    A class of FullNode, generated by MasterProcess

    """
    # 클래스 최초 생성 함수
    def __init__(self,*args) -> None:
        # args
        # genesisBlock,ip,port,r_pipe,peer_list,w_pipe,fullnode_i
        super().__init__()
        self.Blockchain         =   BlockChain(args[0],0)
        self.memset             =   set()
        self.node_Socket        =   socket(AF_INET,SOCK_DGRAM)
        self.ip                 =   args[1]
        self.port               =   args[2]
        self.read_pipe          =   args[3]
        self.peer_fullnode_ip   =   args[4]
        self.write_pipe         =   args[5]
        self.node_number        =   args[6]
        
    
    def __str__(self):
        myself = '######################################################################'
        myself += str(self.node_number) + '\'s longest_chain:'
        myself += self.Blockchain.__str__()
        myself += '######################################################################'
        return myself
    
    def run(self):
        Thread(target=self.listen_transaction).start()
        Thread(target=self.mining_process).start()
            

    # 트랜잭션 인증 함수
    def validate_transaction(self, user_transactions,user_id,i,tx) -> bool:
        
        if len(user_transactions[user_id])>1:    
            prevTx = user_transactions[user_id][-2][i]
            
            ## 1) txs(k)'s buyer == txs(k-1)'s seller
            if prevTx['output']!=tx['input']:
                return False 
            ## 2) Check immutable value
            if prevTx['Vid']!=tx['Vid']: return False
            if prevTx['modelName']!=tx['modelName']: return False
            if prevTx['manufacturedTime']!=tx['manufacturedTime']: return False
            
        ## 3) Verify signature
        if not verify_sig(tx['sig'],VerifyingKey.from_string(tx['input']),tx['txid']): return False
        
        return True

    #def


    # 채굴 함수
    def mining_process(self):
        """
        Mining process
        """
        while True:
            txs = set()
            for _ in range(min(4,len(self.memset))):
                txs.add(self.memset.pop())
            self.memset.update(txs)                 # mining 중간에 해당 프로세스가 중단되는 것을 고려하여, 아직 memset에서 pop 하지 않음
            # 적절히 txs 안에 memset에서 골라오는 함수 필요
            mined_Block = self.Blockchain.mining(list(txs))
            self.write_pipe.send((self.node_number,mined_Block))
            self.memset = self.memset - txs         # mining 중간에 프로세스 종료되지 않고 잘 전달되었다면, memset에서 사용한 트랜잭션 pop
            
            # 채굴한 block socket으로 peer FullNode로 flooding 하는 함수 필요

        

    # 채굴된 블락 받는 함수
    # from another FullNode
    def listen_block(self):
        pass

    # 채굴한 블락 flooding 함수
    # to another FullNode
    def send_block(self,block):
        pass
    
    # 트랜잭션 받는 함수
    # from UserNode
    def listen_transaction(self):
        flag = True
        user_transactions  =   dict()
        while flag:
            for pipe in self.read_pipe:
                data,user_id = pipe.recv()
                if data==-1:
                    pipe.close()
                    flag = False
                    continue
                if user_id not in user_transactions.keys():
                    user_transactions[user_id] = []
                user_transactions[user_id].append([0]*len(data))
                for i in range(len(data)):
                    if self.validate_transaction(user_transactions,user_id,i,data[i]):
                        user_transactions[user_id][-1][i]=data[i]
                        self.memset.add(str(data[i]))