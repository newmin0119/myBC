import sys, os
import threading
from socket import *
from multiprocessing import Process
sys.path.append(os.path.dirname(os.path.abspath(os.path.dirname(__file__))))

from Crypto_tools import *
from Structure.Blocks import *
from Structure.Blockchain import *


class FullNode(Process):
    """
    A class of FullNode, generated by MasterProcess

    """
    # 클래스 최초 생성 함수
    def __init__(self,*args) -> None:
        # args
        # genesisBlock,ip,port,r_pipe,peer_list,w_pipe,fullnode_i
        super().__init__()
        self.Blockchain         =   BlockChain(args[0],0)
        self.memset             =   set()
        self.node_Socket        =   socket(AF_INET,SOCK_DGRAM)
        self.ip                 =   args[1]
        self.port               =   args[2]
        self.read_pipe          =   args[3]
        self.peer_fullnode_ip   =   args[4]
        self.write_pipe         =   args[5]
        self.node_number        =   args[6]
        self.user_transactions  =   dict()
    
    def __str__(self):
        myself = '######################################################################'
        myself += str(self.node_number) + '\'s longest_chain:'
        myself += self.Blockchain.__str__()
        myself += '######################################################################'
        return myself
    
    def run(self):
        threading.Thread(target=self.listen_transaction()).start()

        

    # 트랜잭션 인증 함수
    def validate_transaction(self, tx) -> bool:
        '''
        ## 1) txs(k)'s buyer == txs(k-1)'s seller
        if txs[i]['input']!=txs[i-1]['output']: return False 
        
        ## 2) Check immutable value
        if txs[i]['Vid']!=txs[i-1]['Vid']: return False
        if txs[i]['modelName']!=txs[i]['modelName']: return False
        if txs[i]['manufacturedTime']!=txs[i]['manufacturedTime']: return False
        '''
        ## 3) Verify signature
        if not verify_sig(tx['sig'],tx['input'],tx['txid']): return False
        
        return True

    #def


    # 채굴 함수
    def mining_process(self):
        """
        Mining process
        """
        while True:
            txs = []
            # 적절히 txs 안에 memset에서 골라오는 함수 필요
            mined_Block = self.Blockchain.mining(txs)
            self.write_pipe.send(mined_Block)
            # 채굴한 block socket으로 peer FullNode로 flooding 하는 함수 필요
    
        

    # 채굴된 블락 받는 함수
    # from another FullNode
    def listen_block(self):
        pass

    # 채굴한 블락 flooding 함수
    # to another FullNode
    def send_block(self,block):
        pass
    
    # 트랜잭션 받는 함수
    # from UserNode
    def listen_transaction(self):
        flag = True
        while flag:
            for pipe in self.read_pipe:
                data,user_id = pipe.recv()
                if data==-1:
                    pipe.close()
                    flag = False
                    continue
                if user_id not in self.user_transactions.keys():
                    self.user_transactions[user_id] = []
                self.user_transactions[user_id].append([0]*len(data))
                for i in range(len(data)):
                    if self.validate_transaction(data[i]):
                        self.user_transactions[user_id][-1][i]=data[i]
                        self.memset.add((user_id,data[i]['trandeCnt'],i))
                        # print(x) # -> 정상적으로 추가된 transaction 출력
                for id,x,carnum in self.memset:
                    print(id, ': ', x, '번째 ',carnum,'번 차량')